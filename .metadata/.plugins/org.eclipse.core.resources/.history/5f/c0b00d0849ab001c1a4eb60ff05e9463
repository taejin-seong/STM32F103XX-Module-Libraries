/*
 * max7219_8x8_led.c
 *
 *  Created on: 2022. 3. 23.
 *      Author: sungt
 */


#include "dot_matrix.h"
#include "spi.h"



uint8_t matrix_onoff_flags = 0;

/*  Buffer that contains the string to display in bit format.
 *  Horizontal line in this table correspond to a vertical line on LED matrice */
#define NB_MAX_CHAR_IN_STRING 	50
#define MATRIX_COLUMN_NUMBER 	(8 * 4)
static uint8_t 	  display_buffer[8 * NB_MAX_CHAR_IN_STRING];


/* Buffer to send data over SPI */
static uint8_t 	  serial_format[4 * ML_NB_MAX7219];


/* Function prototypes -------------------------------------------------------*/
static uint16_t dotmatrix_StoreStringInBuffer( char string[]);
static uint8_t  dotmatrix_DisplayBuffer( uint8_t *BufferToDisplay);


/* ASCII table */
const uint8_t ASCII[95][8] = {
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  // Code pour char
        { 0x00, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00 },  // Code pour char !
        { 0x00, 0x00, 0x06, 0x08, 0x00, 0x06, 0x08, 0x00 },  // Code pour char "
        { 0x00, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00 },  // Code pour char #
        { 0x00, 0x26, 0x49, 0x49, 0xFF, 0x49, 0x32, 0x00 },  // Code pour char $
        { 0x00, 0x46, 0x26, 0x10, 0x08, 0x64, 0x62, 0x00 },  // Code pour char %
        { 0x00, 0x70, 0x8E, 0x89, 0x99, 0x76, 0xC0, 0x00 },  // Code pour char &
        { 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },  // Code pour char '
        { 0x00, 0x7E, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00 },  // Code pour char (
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x7E, 0x00 },  // Code pour char )
        { 0x00, 0x00, 0x07, 0x05, 0x07, 0x00, 0x00, 0x00 },  // Code pour char * replaced by °            { 0x00, 0x00, 0x0A, 0x04, 0x0A, 0x00, 0x00, 0x00 },
        { 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00 },  // Code pour char +
        { 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00 },  // Code pour char ,
        { 0x00, 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00 },  // Code pour char -
        { 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00 },  // Code pour char .
        { 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 },  // Code pour char /
        { 0x00, 0x7E, 0xC1, 0xB1, 0x8D, 0x83, 0x7E, 0x00 },  // Code pour char 0
        { 0x00, 0x04, 0x02, 0x01, 0xFF, 0x00, 0x00, 0x00 },  // Code pour char 1
        { 0x00, 0xE6, 0x91, 0x91, 0x89, 0x89, 0x86, 0x00 },  // Code pour char 2
        { 0x00, 0x42, 0x81, 0x89, 0x89, 0x89, 0x76, 0x00 },  // Code pour char 3
        { 0x00, 0x30, 0x28, 0x24, 0x22, 0xFF, 0x20, 0x00 },  // Code pour char 4
        { 0x00, 0x4F, 0x89, 0x89, 0x89, 0x89, 0x71, 0x00 },  // Code pour char 5
        { 0x00, 0x7E, 0x89, 0x89, 0x89, 0x89, 0x72, 0x00 },  // Code pour char 6
        { 0x00, 0x01, 0x01, 0xF1, 0x09, 0x05, 0x03, 0x00 },  // Code pour char 7
        { 0x00, 0x76, 0x89, 0x89, 0x89, 0x89, 0x76, 0x00 },  // Code pour char 8
        { 0x00, 0x4E, 0x91, 0x91, 0x91, 0x91, 0x7E, 0x00 },  // Code pour char 9
        { 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00 },  // Code pour char :
        { 0x00, 0x00, 0x80, 0x68, 0x00, 0x00, 0x00, 0x00 },  // Code pour char ;
        { 0x00, 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00 },  // Code pour char <
        { 0x00, 0x00, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00 },  // Code pour char =
        { 0x00, 0x00, 0x00, 0x44, 0x28, 0x10, 0x00, 0x00 },  // Code pour char >
        { 0x00, 0x06, 0x01, 0xB1, 0x09, 0x09, 0x06, 0x00 },  // Code pour char ?
        { 0x00, 0x7E, 0x99, 0xA5, 0xA5, 0xB9, 0x5E, 0x00 },  // Code pour char @
        { 0x00, 0xE0, 0x1C, 0x13, 0x13, 0x1C, 0xE0, 0x00 },  // Code pour char A
        { 0x00, 0xFF, 0x89, 0x89, 0x89, 0x8E, 0x70, 0x00 },  // Code pour char B
        { 0x00, 0x7E, 0x81, 0x81, 0x81, 0x81, 0x42, 0x00 },  // Code pour char C
        { 0x00, 0xFF, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00 },  // Code pour char D
        { 0x00, 0xFF, 0x89, 0x89, 0x89, 0x81, 0x81, 0x00 },  // Code pour char E
        { 0x00, 0xFF, 0x09, 0x09, 0x09, 0x01, 0x01, 0x00 },  // Code pour char F
        { 0x00, 0x7E, 0x81, 0x91, 0x91, 0x51, 0xF2, 0x00 },  // Code pour char G
        { 0x00, 0xFF, 0x08, 0x08, 0x08, 0x08, 0xFF, 0x00 },  // Code pour char H
        { 0x00, 0x00, 0x81, 0xFF, 0x81, 0x00, 0x00, 0x00 },  // Code pour char I
        { 0x00, 0x60, 0x80, 0x80, 0x80, 0x80, 0x7F, 0x00 },  // Code pour char J
        { 0x00, 0xFF, 0x08, 0x18, 0x24, 0x42, 0x81, 0x00 },  // Code pour char K
        { 0x00, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00 },  // Code pour char L
        { 0x00, 0xFF, 0x02, 0x0C, 0x0C, 0x02, 0xFF, 0x00 },  // Code pour char M
        { 0x00, 0xFF, 0x03, 0x0C, 0x30, 0xC0, 0xFF, 0x00 },  // Code pour char N
        { 0x00, 0x7E, 0x81, 0x81, 0x81, 0x81, 0x7E, 0x00 },  // Code pour char O
        { 0x00, 0xFF, 0x11, 0x11, 0x11, 0x11, 0x0E, 0x00 },  // Code pour char P
        { 0x00, 0x7E, 0x81, 0x81, 0xA1, 0x41, 0xBE, 0x00 },  // Code pour char Q
        { 0x00, 0xFF, 0x09, 0x09, 0x09, 0x39, 0xC6, 0x00 },  // Code pour char R
        { 0x00, 0x46, 0x89, 0x89, 0x89, 0x89, 0x72, 0x00 },  // Code pour char S
        { 0x00, 0x00, 0x01, 0x01, 0xFF, 0x01, 0x01, 0x00 },  // Code pour char T
        { 0x00, 0x7F, 0x80, 0x80, 0x80, 0x80, 0x7F, 0x00 },  // Code pour char U
        { 0x00, 0x0F, 0x30, 0xC0, 0xC0, 0x30, 0x0F, 0x00 },  // Code pour char V
        { 0x00, 0x7F, 0x80, 0x70, 0x70, 0x80, 0x7F, 0x00 },  // Code pour char W
        { 0x00, 0xC3, 0x24, 0x18, 0x18, 0x24, 0xC3, 0x00 },  // Code pour char X
        { 0x00, 0x07, 0x08, 0xF0, 0xF0, 0x08, 0x07, 0x00 },  // Code pour char Y
        { 0x00, 0xC1, 0xA1, 0x91, 0x89, 0x85, 0x83, 0x00 },  // Code pour char Z
        { 0x00, 0xFF, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00 },  // Code pour char [
        { 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00 },  // Code pour char BackSlash
        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xFF, 0x00 },  // Code pour char ]
        { 0x00, 0x00, 0x04, 0x02, 0x02, 0x04, 0x00, 0x00 },  // Code pour char ^
        { 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00 },  // Code pour char _
        { 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00 },  // Code pour char `
        { 0x00, 0x00, 0x20, 0x54, 0x54, 0x78, 0x00, 0x00 },  // Code pour char a
        { 0x00, 0x00, 0x7E, 0x48, 0x48, 0x30, 0x00, 0x00 },  // Code pour char b
        { 0x00, 0x00, 0x38, 0x44, 0x44, 0x28, 0x00, 0x00 },  // Code pour char c
        { 0x00, 0x00, 0x30, 0x48, 0x48, 0x7E, 0x00, 0x00 },  // Code pour char d
        { 0x00, 0x00, 0x38, 0x54, 0x54, 0x58, 0x00, 0x00 },  // Code pour char e
        { 0x00, 0x00, 0x7C, 0x0A, 0x0A, 0x02, 0x00, 0x00 },  // Code pour char f
        { 0x00, 0x00, 0x18, 0xA4, 0xA8, 0x7C, 0x00, 0x00 },  // Code pour char g
        { 0x00, 0x00, 0x7E, 0x08, 0x08, 0x70, 0x00, 0x00 },  // Code pour char h
        { 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x00 },  // Code pour char i
        { 0x00, 0x00, 0x80, 0x80, 0x7A, 0x00, 0x00, 0x00 },  // Code pour char j
        { 0x00, 0x00, 0x7E, 0x10, 0x28, 0x40, 0x00, 0x00 },  // Code pour char k
        { 0x00, 0x00, 0x00, 0x7E, 0x40, 0x00, 0x00, 0x00 },  // Code pour char l
        { 0x00, 0x7C, 0x08, 0x04, 0x78, 0x04, 0x78, 0x00 },  // Code pour char m
        { 0x00, 0x00, 0x7C, 0x08, 0x04, 0x78, 0x00, 0x00 },  // Code pour char n
        { 0x00, 0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00 },  // Code pour char o
        { 0x00, 0x00, 0xFC, 0x28, 0x24, 0x18, 0x00, 0x00 },  // Code pour char p
        { 0x00, 0x00, 0x18, 0x24, 0x28, 0xFC, 0x00, 0x00 },  // Code pour char q
        { 0x00, 0x00, 0x7C, 0x08, 0x04, 0x08, 0x00, 0x00 },  // Code pour char r
        { 0x00, 0x00, 0x08, 0x54, 0x54, 0x20, 0x00, 0x00 },  // Code pour char s
        { 0x00, 0x00, 0x3E, 0x48, 0x40, 0x00, 0x00, 0x00 },  // Code pour char t
        { 0x00, 0x00, 0x3C, 0x40, 0x40, 0x3C, 0x00, 0x00 },  // Code pour char u
        { 0x00, 0x00, 0x1C, 0x60, 0x60, 0x1C, 0x00, 0x00 },  // Code pour char v
        { 0x00, 0x3C, 0x40, 0x70, 0x70, 0x40, 0x3C, 0x00 },  // Code pour char w
        { 0x00, 0x00, 0x6C, 0x10, 0x10, 0x6C, 0x00, 0x00 },  // Code pour char x
        { 0x00, 0x00, 0x0C, 0x90, 0x90, 0x7C, 0x00, 0x00 },  // Code pour char y
        { 0x00, 0x00, 0x64, 0x54, 0x54, 0x4C, 0x00, 0x00 },  // Code pour char z
        { 0x00, 0x00, 0x08, 0x76, 0x81, 0x00, 0x00, 0x00 },  // Code pour char {
        { 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00 },  // Code pour char |
        { 0x00, 0x00, 0x00, 0x81, 0x76, 0x08, 0x00, 0x00 },  // Code pour char }
        { 0x80, 0x44, 0x34, 0xFB, 0x34, 0x44, 0x80, 0x00 }   // Code pour char ~   /* Replaced by the hermine old: { 0x00, 0x00, 0x10, 0x08, 0x10, 0x08, 0x00, 0x00 }*/
        };







static uint16_t dotmatrix_StoreStringInBuffer( char string[])
{
	uint8_t cptCharString = 0;
	uint8_t cptCol;
	uint8_t NbCharInString = (uint8_t)strlen((const char *)string);
	uint8_t indexInAsciiTable;
	uint16_t bufferIndex = 0;

	if( NB_MAX_CHAR_IN_STRING <= NbCharInString )
		return 1;

	bufferIndex = 0;
	while( cptCharString < NbCharInString)
	{
		indexInAsciiTable = (uint8_t)(string[cptCharString] - ' ');

		for( cptCol=0; cptCol<7; cptCol++)
		{
			display_buffer[bufferIndex] = ASCII[indexInAsciiTable][cptCol];
			bufferIndex++;
		}

		cptCharString++;
	}

	return bufferIndex;
}


static uint8_t dotmatrix_DisplayBuffer( uint8_t *BufferToDisplay)
{
	uint8_t cpt_digit;

	uint8_t module;
	uint16_t bufferColIndex;
	uint8_t col;
	uint8_t buffer[32];


	//matriceLed_SwitchOnOff( MATRICE_OFF);
	bufferColIndex = 0;

	/* Re-arrange data in display buffer */
	for( module = 0; module < 4; module++)
	{
		for( col=0; col<8; col++)
		{
			uint8_t cpt = 8;

			buffer[bufferColIndex] = 0;
			while( cpt > 0)
			{
				cpt--;
				buffer[bufferColIndex] |= ((BufferToDisplay[(module*8) + cpt] >> (bufferColIndex%8)) & 0x01) << (7-cpt);
			}
			bufferColIndex++;
		}
	}

	for( cpt_digit = 0; cpt_digit<8; cpt_digit++)
	{
		serial_format[1] = DIGIT_0 + cpt_digit;
		serial_format[0] = buffer[cpt_digit];

		serial_format[3] = DIGIT_0 + cpt_digit;
		serial_format[2] = buffer[cpt_digit+8];

		serial_format[5] = DIGIT_0 + cpt_digit;
		serial_format[4] = buffer[cpt_digit+16];

		serial_format[7] = DIGIT_0 + cpt_digit;
		serial_format[6] = buffer[cpt_digit+24];

	    DOT_MATRIX_SPI_CS_ENABLE();
	    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, serial_format, ML_NB_MAX7219, 100);
	    DOT_MATRIX_SPI_CS_DISABLE();
	}

	delay_ms(50);

	return 0;
}


/* Dot Matrix Pin 변경 시 헤더파일만 변경하면 됨  */
void dotmatrix_Init(void)
{
    /* 클럭 활성화는  bsp.c 에서 처리 함*/

	uint8_t cpt;

    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(DOT_MATRIX_SPI_CS_PORT, DOT_MATRIX_SPI_CS_PIN, GPIO_PIN_SET);

    /*Configure GPIO pins : PBPin PBPin */
    GPIO_InitStruct.Pin   = DOT_MATRIX_SPI_CS_PIN ;
    GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull  = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(DOT_MATRIX_SPI_CS_PORT, &GPIO_InitStruct);



    /* Set Dot Matrix in Shutdown Mode */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = 0x00;
		serial_format[2*cpt + 1] = SHUTDOWN;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();

    delay_ms(5);


	/* Set normal operation mode */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = 0x01;
		serial_format[2*cpt + 1] = SHUTDOWN;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();

    delay_ms(50);


	/* Set decode mode to no decode */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = 0x00;
		serial_format[2*cpt + 1] = DECODE_MODE;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();

    delay_ms(5);


	/* Set default intensity */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = 0x00;
		serial_format[2*cpt + 1] = INTENSITY;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();

    delay_ms(5);

	/* Set display to all digit */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = 0x07;
		serial_format[2*cpt + 1] = SCAN_LIMIT;

	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();

	/* Matrice is ON */
    matrix_onoff_flags = 1;
}


void dotmatrix_DisplayTestMode(uint8_t OnOff)
{
	uint8_t cpt;

	if(OnOff)
	{
		OnOff = 0x01;
	}

	else
	{
		OnOff = 0x00;
	}

	/* Set display to all digit */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = OnOff;
		serial_format[2*cpt + 1] = DISPLAY_TEST;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();
}


bool dotmatrix_DisplayOnOff(uint8_t OnOff)
{
	uint8_t cpt;
	bool ret = false;

	if( OnOff)
		OnOff = 0x01;
	else
		OnOff = 0x00;

	/* If already in requested state, just return */
	if( matrix_onoff_flags == OnOff)
		return ret;

	/* Set display to all digit */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = OnOff;
		serial_format[2*cpt + 1] = SHUTDOWN;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();

    matrix_onoff_flags = OnOff;

    return ret;

}


void dotmatrix_SetIntensity(uint8_t intensity)
{
	uint8_t cpt;

	intensity = ( intensity < 0x10 ? intensity : 0x0F);

	/* Set default intensity */
	for( cpt=0; cpt<ML_NB_MAX7219; cpt++)
	{
		serial_format[2*cpt] = intensity;
		serial_format[2*cpt + 1] = INTENSITY;
	}
    DOT_MATRIX_SPI_CS_ENABLE();
    HAL_SPI_Transmit(&DOT_MATRIX_SPI_PORT, (uint8_t *)serial_format, ML_NB_MAX7219, 100);
    DOT_MATRIX_SPI_CS_DISABLE();
}


void dotmatrix_Position(uint8_t index, uint8_t position)
{
	uint8_t cpt = 8;
	uint8_t val = 0;

	while ( cpt > 0)
	{
		cpt --;
		val |= ((ASCII[index][cpt] >> position) & 0x01) << (7-cpt);
	}
}


bool dotmatrix_Str(char string[])
{
	uint16_t NbColInMatrix;
	uint8_t bufferColIndex = 0;
	bool ret = false;

	memset( display_buffer, 0x00, 8*NB_MAX_CHAR_IN_STRING);

	/* First : store the string to display in the matrix memory buffer
	 * It's this matrix that will be displayed. 	 */
	NbColInMatrix = dotmatrix_StoreStringInBuffer(string);
	if( !NbColInMatrix)
		return !ret;

	/* Second : Display the matrice content */
	bufferColIndex = 0;
	do
	{
		dotmatrix_DisplayBuffer(&display_buffer[bufferColIndex]);
		bufferColIndex++;
	} while( MATRIX_COLUMN_NUMBER < (NbColInMatrix-bufferColIndex));

	return ret;

}
